//  Copyright (c) 2015 space150, Inc.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
//  associated documentation files (the "Software"), to deal in the Software without restriction, including
//  without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
//  following conditions:
//
//  The above copyright notice and this permission notice shall be included in all copies or substantial
//  portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
//  LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
//  EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
//  THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <AES.h>
#include <RFduinoBLE.h>

// LOCK SPECIFIC CONFIG

// both the key and hello values are generated by the iOS application using the LKSecurityManager class
// for example (in Swift):
//
//    var security = LKSecurityManager()
//    security.generateKeyForLockName("LOCK NAME")
//
// will generate the key and hello handshake that you can copy/paste into this sketch.

#define LOCK_NAME "LOCK NAME"
#define CUSTOM_UUID "ENTER YOUR CUSTOM UUID HERE"
byte key[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
char hello[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

// END LOCK SPECIFIC CONFIG

#define COMMAND_NONE   0
#define COMMAND_LOCK   1
#define COMMAND_UNLOCK 2

#define UNLOCK_COOLDOWN_MILLIS 7000

#define LOCK_PIN  6
#define LED_PIN_R 2
#define LED_PIN_G 3
#define LED_PIN_B 4

bool locked = true;
unsigned long last_command_millis = 0;
int current_command = COMMAND_LOCK;

#define MAX_HELLO_ATTEMPTS 10

bool send_hello = false;
int hello_attempts = 0;

AES aes;

void setup() 
{
  Serial.begin(9600);
  
  // setup the leds for output
  pinMode(LED_PIN_R, OUTPUT);
  pinMode(LED_PIN_G, OUTPUT);  
  pinMode(LED_PIN_B, OUTPUT);
  pinMode(LOCK_PIN, OUTPUT);

  RFduinoBLE.deviceName = "sl-lock";
  RFduinoBLE.advertisementData = LOCK_NAME;
  RFduinoBLE.customUUID = CUSTOM_UUID;
  
  // start the BLE stack
  RFduinoBLE.begin();
}

void loop() 
{  
  attempt_send_hello();
  check_for_unlock_timeout();
  process_current_command();
    
  // switch to lower power mode
  RFduino_ULPDelay(350);
}

// COMMAND HANDLERS

void attempt_send_hello()
{
  if ( send_hello == true ) 
  {
    Serial.print("sending hello, attempt #"); Serial.println(hello_attempts);
    RFduinoBLE.send(hello, 16);
    
    hello_attempts += 1;
    if ( hello_attempts >= MAX_HELLO_ATTEMPTS )
    {
      send_hello = false;
      hello_attempts = 0;
    }
  }
}

void check_for_unlock_timeout()
{
  if ( locked == false )
  {
    // check to see if we are unlocked and the lock timeout acurred
    unsigned long current_millis = millis();
    if ( (current_millis - last_command_millis) > UNLOCK_COOLDOWN_MILLIS )
      current_command = COMMAND_LOCK;
  }
}

void process_current_command()
{
  if ( current_command != COMMAND_NONE)
  {
    if ( current_command == COMMAND_UNLOCK ) 
      unlock_door();
    else if ( current_command == COMMAND_LOCK )
      lock_door();
    
    current_command = COMMAND_NONE;
  }
}

void lock_door()
{
  locked = true;
  last_command_millis = millis();
  
  analogWrite(LED_PIN_R, 255);
  analogWrite(LED_PIN_G, 0);
  analogWrite(LED_PIN_B, 0);
  
  RFduinoBLE.send('l');
  
  digitalWrite(LOCK_PIN, LOW);
}

void unlock_door()
{
  locked = false;
  last_command_millis = millis();
  
  analogWrite(LED_PIN_R, 0);
  analogWrite(LED_PIN_G, 255);
  analogWrite(LED_PIN_B, 0);
  
  RFduinoBLE.send('u');
  
  digitalWrite(LOCK_PIN, HIGH);
}

void show_error()
{
  analogWrite(LED_PIN_R, 0);
  analogWrite(LED_PIN_G, 0);
  analogWrite(LED_PIN_B, 255);
}

// SECURITY

int decrypt_command(char *data, int len)
{
  Serial.println("-----------------------------");
  Serial.print("data received, len: "); Serial.println(len);
  Serial.print("data: ");
 
  byte encrypted[len];
  byte decrypted[len];
  
  for (byte i = 0 ; i < len ; i++)
  {
    byte val = (byte)data[i];
    encrypted[i] = val;
    Serial.print( (char)val );
  }
  
  Serial.println(" ");

  byte success = aes.set_key( key, 128 );
  if ( success == 0 )
  {
    success = aes.decrypt( encrypted, decrypted );
    if ( success == 0 )
    {
      Serial.print("Decrypted string: ");
      
      char command_char;
      String time_string = "";
      for (byte i = 0 ; i < len ; i++)
      {
        byte val = decrypted[i];
        Serial.print( (char)val );
        
        if ( i == 0 )
          command_char = (char)val;
        else
          time_string += (char)val;
      }
      
      Serial.println("");
      
      // convert time string to timestamp
      unsigned int timestamp = time_string.toInt();
      
      Serial.print("Timestamp: "); Serial.println(timestamp);
      Serial.print("Command: "); Serial.println(command_char);
      
      // VERIFY THE TIMESTAMP
      // we will probably need some additional hardware (wifi?) for this
      // TODO
      
      if ( command_char == 'u' || command_char == 'U' )
        return COMMAND_UNLOCK;
      else if ( command_char == 'l' || command_char == 'L' )
        return COMMAND_LOCK;
    }
    else
      Serial.println("failed to decrypt string!");
  }
  else
    Serial.println("failed to set key!");
  
  show_error();
  
  return COMMAND_NONE;
}

// RFDUINO BLE HANDLERS

void RFduinoBLE_onConnect() 
{
  send_hello = true;
  hello_attempts = 0;
}

void RFduinoBLE_onDisconnect() 
{
  // reset the hello handshake on disconnect, they don't want to talk to us anyway :(
  send_hello = false;
  hello_attempts = 0;
}

void RFduinoBLE_onReceive(char *data, int len) 
{
  // once we receive data, the hello handshake probably worked!
  send_hello = false;
  hello_attempts = 0;
  
  if ( len >= 16 ) 
    current_command = decrypt_command(data, len);
}
